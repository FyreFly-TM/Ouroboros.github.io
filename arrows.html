<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arrow Reference - Ouroboros</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    <div class="nav-inner">
      <a href="index.html" class="brand"><img src="OuroborosLogo.png" alt="Ouroboros" class="logo"><span class="brand-text">Ouroboros</span></a>
      <div class="search-container">
        <div class="search-wrapper">
          <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" />
          </svg>
          <input type="text" id="doc-search" class="search-input" placeholder="Search (Ctrl+K)" autocomplete="off" />
          <div id="search-results" class="search-results"></div>
        </div>
      </div>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <div class="nav-dropdown">
          <span class="nav-dropdown-trigger">Learn</span>
          <div class="nav-dropdown-menu">
            <a href="getting_started.html">Get Started</a>
            <a href="cheatsheet.html">Cheat Sheet</a>
            <a href="examples.html">Examples</a>
          </div>
        </div>
        <div class="nav-dropdown">
          <span class="nav-dropdown-trigger">Language</span>
          <div class="nav-dropdown-menu">
            <a href="arrows.html">Arrows</a>
            <a href="flows.html">Flows</a>
            <a href="tokens.html">Tokens</a>
            <div class="menu-divider"></div>
            <a href="reference.html">Full Reference</a>
          </div>
        </div>
        <div class="nav-dropdown">
          <span class="nav-dropdown-trigger">Libraries</span>
          <div class="nav-dropdown-menu">
            <a href="stdlib.html">Standard Library</a>
            <a href="windows.html">Windowing</a>
            <a href="keycodes.html">Key Codes</a>
            <div class="menu-divider"></div>
            <a href="domains.html">Domains</a>
            <a href="files.html">File Types</a>
          </div>
        </div>
        <div class="nav-dropdown">
          <span class="nav-dropdown-trigger">Tools</span>
          <div class="nav-dropdown-menu">
            <a href="rex_aot.html">REX &amp; AOT</a>
            <a href="downloads.html">Downloads</a>
          </div>
        </div>
      </div>
    </div>
  </nav>

  <div class="doc-layout">
    <aside class="doc-panel toc">
      <h3>Arrow Types</h3>
      <ul>
        <li><a href="#quick-ref">‚ö° Quick Reference</a></li>
        <li><a href="#when-to-use">üéØ When to Use Which</a></li>
        <li><a href="#overview">Overview</a></li>
      </ul>
      <h4 style="margin-top: 16px; color: var(--accent);">Core Arrows</h4>
      <ul>
        <li><a href="#forward">Forward (‚Üí)</a></li>
        <li><a href="#pull">Pull (‚Üê)</a></li>
        <li><a href="#sync">Sync (‚Üî)</a></li>
        <li><a href="#fork">Fork (-<)</a></li>
      </ul>
      <h4 style="margin-top: 16px; color: var(--success);">Reactive Arrows</h4>
      <ul>
        <li><a href="#funnel">Funnel (>-, |>-)</a></li>
        <li><a href="#continuous">Continuous (-|>, <|-, <|-|>, -<|)</a></li>
      </ul>
      <h4 style="margin-top: 16px; color: var(--warning);">Special Arrows</h4>
      <ul>
        <li><a href="#fuzzy">Fuzzy (~>, <~, <~>)</a></li>
        <li><a href="#solver">Solver (=>, ‚âà>)</a></li>
        <li><a href="#transfer">Transfer (-|->, <-|-, <-|->)</a></li>
        <li><a href="#sever">Sever (-||->, <-||-, <-||->)</a></li>
      </ul>
      <h4 style="margin-top: 16px; color: #9b59b6;">Advanced</h4>
      <ul>
        <li><a href="#async">Async (->>, <<-, <<->>)</a></li>
        <li><a href="#async">Await (->|, |<-, |<->|)</a></li>
        <li><a href="#conditional-arrows">Conditional Arrows</a></li>
        <li><a href="#gates">Conditional Gates</a></li>
        <li><a href="#gates" style="color: var(--success);">‚Ü≥ If-Else Pattern</a></li>
        <li><a href="#chaining">Arrow Chaining</a></li>
      </ul>
    </aside>

    <main class="doc-panel doc-content">
      <div class="doc-header">
        <div class="badge">Language Reference</div>
        <h1>Arrow Semantics</h1>
        <p>Arrows are the heart of Ouroboros. Every arrow expresses a specific data flow intent‚Äîmaster these and you've mastered the language.</p>
      </div>

      <!-- QUICK REFERENCE -->
      <div class="doc-section" id="quick-ref">
        <h2>‚ö° Quick Reference</h2>
        <p>The essential arrows you'll use 90% of the time:</p>
        
        <div class="grid" style="gap: 16px; margin: 20px 0;">
          <div class="card" style="border-left: 4px solid var(--accent);">
            <h3 style="margin-top: 0;"><code style="font-size: 18px;">-></code> Forward</h3>
            <p><strong>Use when:</strong> Sending data to a function or Print</p>
            <div class="code-block">"Hello!" -> Print
value -> ProcessData -> SaveResult</div>
          </div>
          <div class="card" style="border-left: 4px solid var(--success);">
            <h3 style="margin-top: 0;"><code style="font-size: 18px;"><-</code> Pull</h3>
            <p><strong>Use when:</strong> Capturing a return value</p>
            <div class="code-block">result <- Calculate(10, 5)
x, y <- GetCoordinates()</div>
          </div>
          <div class="card" style="border-left: 4px solid var(--warning);">
            <h3 style="margin-top: 0;"><code style="font-size: 18px;"><-></code> Sync</h3>
            <p><strong>Use when:</strong> Two variables must stay equal</p>
            <div class="code-block">model <-> view
// Now changing either updates both</div>
          </div>
          <div class="card" style="border-left: 4px solid #9b59b6;">
            <h3 style="margin-top: 0;"><code style="font-size: 18px;">-<</code> Fork</h3>
            <p><strong>Use when:</strong> Broadcasting to multiple handlers</p>
            <div class="code-block">event -< Logger, UI, Analytics</div>
          </div>
        </div>
      </div>

      <!-- WHEN TO USE WHICH -->
      <div class="doc-section" id="when-to-use">
        <h2>üéØ When to Use Which Arrow</h2>
        <p>Choose the right arrow for your situation:</p>
        
        <table class="table" style="margin: 20px 0;">
          <thead>
            <tr><th style="width: 25%;">I want to...</th><th style="width: 15%;">Arrow</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>Print output</td>
              <td><code>-></code></td>
              <td><code>"Hello" -> Print</code></td>
            </tr>
            <tr>
              <td>Call a function</td>
              <td><code>-></code></td>
              <td><code>data -> ProcessItem</code></td>
            </tr>
            <tr>
              <td>Capture a return value</td>
              <td><code><-</code> or <code>:=</code></td>
              <td><code>result <- Calculate(x)</code></td>
            </tr>
            <tr>
              <td>Keep two variables synchronized</td>
              <td><code><-></code></td>
              <td><code>playerHP <-> displayHP</code></td>
            </tr>
            <tr>
              <td>Send to multiple handlers at once</td>
              <td><code>-<</code></td>
              <td><code>event -< Log, Save, Notify</code></td>
            </tr>
            <tr>
              <td>React to variable changes</td>
              <td><code>>-</code></td>
              <td><code>health >- OnHealthChanged</code></td>
            </tr>
            <tr>
              <td>Fire-and-forget (async)</td>
              <td><code>->></code></td>
              <td><code>data ->> SlowProcess</code></td>
            </tr>
            <tr>
              <td>Only forward if condition is true</td>
              <td><code>-[cond]-></code></td>
              <td><code>x -[x > 0]-> ProcessPositive</code></td>
            </tr>
            <tr>
              <td>Transfer ownership (move)</td>
              <td><code>-|-></code></td>
              <td><code>cargo -|-> Receiver</code></td>
            </tr>
            <tr>
              <td>Soft influence (fuzzy logic)</td>
              <td><code>~></code></td>
              <td><code>temp ~> Thermostat</code></td>
            </tr>
          </tbody>
        </table>
        
        <div class="card" style="border-left: 4px solid var(--success); margin: 20px 0;">
          <h4>üí° Pro Tip: Start Simple</h4>
          <p>Most programs only need <code>-></code> (forward) and <code><-</code> (pull). Add other arrows only when you have a specific need. Over-using advanced arrows makes code harder to read.</p>
        </div>
      </div>

      <div class="doc-section" id="overview">
        <h2>Overview</h2>
        <p>Ouroboros uses arrows to direct data flow between expressions, variables, and flows. Each arrow type conveys different semantics:</p>
        
        <h3>Core Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Direction</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>-></code></td><td>Forward</td><td>Left ‚Üí Right</td><td>Push data to a destination</td></tr>
            <tr><td><code><-</code></td><td>Pull</td><td>Right ‚Üí Left</td><td>Capture or bind reactively</td></tr>
            <tr><td><code><-></code></td><td>Sync</td><td>Bidirectional</td><td>Keep both sides equal</td></tr>
            <tr><td><code>-<</code></td><td>Fork</td><td>One ‚Üí Many</td><td>Broadcast to multiple targets</td></tr>
          </tbody>
        </table>

        <h3>Continuous/Streaming Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>>-</code></td><td>Funnel</td><td>Stream changes reactively to handler</td></tr>
            <tr><td><code>|>-</code></td><td>Continuous Funnel</td><td>Continuous aggregation stream</td></tr>
            <tr><td><code>-|></code></td><td>Continuous Forward</td><td>Push continuously</td></tr>
            <tr><td><code><|-</code></td><td>Continuous Pull</td><td>Continuously monitor and pull changes</td></tr>
            <tr><td><code><|-|></code></td><td>Continuous Sync</td><td>Bidirectional continuous sync</td></tr>
            <tr><td><code>-<|</code></td><td>Continuous Fork</td><td>Fork to multiple targets on every change</td></tr>
          </tbody>
        </table>

        <h3>Special Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>~></code></td><td>Fuzzy Forward</td><td>Suggest rather than force (soft influence)</td></tr>
            <tr><td><code><~</code></td><td>Fuzzy Pull</td><td>Softly pull with noise/dampening</td></tr>
            <tr><td><code><~></code></td><td>Fuzzy Sync</td><td>Bidirectional soft influence</td></tr>
            <tr><td><code>=></code></td><td>Solver</td><td>Find solutions/paths (constraint-based)</td></tr>
            <tr><td><code>‚âà></code></td><td>Fuzzy Solver</td><td>Soft constraint solving</td></tr>
          </tbody>
        </table>

        <h3>Ownership Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>-|-></code></td><td>Transfer Forward</td><td>Move data, invalidate source</td></tr>
            <tr><td><code><-|-</code></td><td>Transfer Pull</td><td>Pull and take ownership, source invalidated</td></tr>
            <tr><td><code><-|-></code></td><td>Transfer Sync</td><td>Transfer ownership bidirectionally</td></tr>
            <tr><td><code>-||-></code></td><td>Sever Forward</td><td>Break connection, forward final value</td></tr>
            <tr><td><code><-||-</code></td><td>Sever Pull</td><td>Pull and disconnect from source</td></tr>
            <tr><td><code><-||-></code></td><td>Sever Sync</td><td>Sever bidirectional connection</td></tr>
          </tbody>
        </table>

        <h3>Conditional Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code><-[cond]-</code></td><td>Conditional Pull</td><td>Pull only if condition is true</td></tr>
            <tr><td><code><-[cond]-></code></td><td>Conditional Sync</td><td>Sync only if condition is true</td></tr>
            <tr><td><code>-[cond]-></code></td><td>Conditional Forward</td><td>Forward only if condition is true</td></tr>
          </tbody>
        </table>

        <h3>Async Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>->></code></td><td>Async Forward</td><td>Fire-and-forget forward</td></tr>
            <tr><td><code><<-</code></td><td>Async Pull</td><td>Non-blocking capture</td></tr>
            <tr><td><code><<->></code></td><td>Async Sync</td><td>Non-blocking bidirectional</td></tr>
            <tr><td><code>-<<</code></td><td>Async Fork</td><td>Parallel broadcast</td></tr>
            <tr><td><code>>>-</code></td><td>Async Funnel</td><td>Async continuous stream</td></tr>
            <tr><td><code>->|</code></td><td>Await Forward</td><td>Wait then forward</td></tr>
            <tr><td><code>|<-</code></td><td>Await Pull</td><td>Wait for value to be ready</td></tr>
            <tr><td><code>|<->|</code></td><td>Await Sync</td><td>Wait for both sides to be ready</td></tr>
          </tbody>
        </table>
      </div>

      <div class="doc-section" id="forward">
        <h2>Forward Arrow (->)</h2>
        
        <div class="card" style="border-left: 4px solid var(--accent); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Forward Arrow When:</h4>
          <ul class="list">
            <li>Printing output to the console</li>
            <li>Calling a Flow with arguments</li>
            <li>Chaining operations in a pipeline</li>
            <li>Passing data through transformations</li>
          </ul>
        </div>
        
        <p>The forward arrow is the workhorse of Ouroboros‚Äîyou'll use it constantly. Data flows left-to-right, making code read naturally like English.</p>
        
        <h3>Printing Output</h3>
        <div class="code-block">// The most common use: send values to Print
"Hello, World!" -> Print
42 -> Print
myVariable -> Print

// String concatenation before printing
"Score: " + score -> Print
"Player " + name + " has " + health + " HP" -> Print</div>

        <h3>Calling Flows</h3>
        <div class="code-block">// Pass a value to a flow
playerInput -> ProcessCommand

// Pass multiple values (comma-separated)
x, y -> MoveToPosition
damage, target -> ApplyDamage</div>

        <h3>Chaining Operations</h3>
        <p><strong>Best Practice:</strong> Chain arrows to create clear data pipelines:</p>
        <div class="code-block">// Data flows through each step left-to-right
input -> Validate -> Transform -> Store

// Each flow receives the return value of the previous
rawData -> Parse -> Clean -> Analyze -> Report</div>

        <h3>Complete Example</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Forward Arrow Best Practices
// Save as: forward_arrow.ouro

Flow Double(n)
    return n * 2

Flow AddTen(n)
    return n + 10

Flow FormatResult(n)
    return "Result: " + n

"=== Forward Arrow Demo ===" -> Print

// Style 1: Direct call to Print
"Hello, World!" -> Print

// Style 2: Chain through multiple flows
5 -> Double -> AddTen -> FormatResult -> Print
// Flow: 5 ‚Üí 10 ‚Üí 20 ‚Üí "Result: 20" ‚Üí printed

// Style 3: Multiple arguments
Flow Add(a, b)
    return a + b

10, 5 -> Add -> Print    // Prints: 15.00

// Expected Output:
// === Forward Arrow Demo ===
// Hello, World!
// Result: 20.00
// 15.00</div>

        <div class="card" style="border-left: 4px solid var(--warning); margin-top: 20px;">
          <h4 style="margin-top: 0;">‚ö†Ô∏è Common Mistake</h4>
          <p>Don't use forward arrow when you need to capture a return value‚Äîuse <code><-</code> or <code>:=</code> instead:</p>
          <div class="code-block">// ‚ùå Wrong: Forward doesn't capture the return
Calculate(10, 5) -> result    // result is undefined!

// ‚úÖ Correct: Use pull or assignment
result <- Calculate(10, 5)
result := Calculate(10, 5)</div>
        </div>
      </div>

      <div class="doc-section" id="pull">
        <h2>Pull Arrow (<-)</h2>
        
        <div class="card" style="border-left: 4px solid var(--success); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Pull Arrow When:</h4>
          <ul class="list">
            <li>Capturing a return value from a Flow</li>
            <li>Capturing multiple return values at once</li>
            <li>Creating a reactive binding to an expression</li>
          </ul>
        </div>
        
        <p>The pull arrow is the counterpart to forward‚Äîit captures values coming <em>back</em> from a Flow. You can also use <code>:=</code> for simple captures.</p>
        
        <h3>Capturing Return Values</h3>
        <div class="code-block">// Both styles work for single returns:
result <- Calculate(10, 5)    // Pull arrow style
result := Calculate(10, 5)    // Assignment style

// Pull arrow is required for multiple returns:
x, y <- GetPosition()
quotient, remainder <- Divide(17, 5)</div>

        <h3>Multiple Return Values</h3>
        <p><strong>Best Practice:</strong> Use pull arrow when capturing multiple values:</p>
        <div class="code-block">// COMPLETE EXAMPLE: Multiple Return Values
// Save as: multi_return.ouro

Flow Divide(a, b)
    quotient := Floor(a / b)
    remainder := a % b
    return quotient, remainder

Flow GetMinMax(arr)
    minVal := arr[0]
    maxVal := arr[0]
    for i = 1, i < Len(arr), i++
        if arr[i] < minVal
            minVal = arr[i]
        if arr[i] > maxVal
            maxVal = arr[i]
    return minVal, maxVal

"=== Multiple Returns Demo ===" -> Print

// Capture both values
q, r <- Divide(17, 5)
"17 √∑ 5 = " + q + " remainder " + r -> Print

// Works with any number of returns
numbers := [3, 1, 4, 1, 5, 9, 2, 6]
minNum, maxNum <- GetMinMax(numbers)
"Min: " + minNum + ", Max: " + maxNum -> Print

// Expected Output:
// === Multiple Returns Demo ===
// 17 √∑ 5 = 3.00 remainder 2.00
// Min: 1.00, Max: 9.00</div>

        <h3>Reactive Binding</h3>
        <p>Create a variable that auto-updates when dependencies change:</p>
        <div class="code-block">width := 10
height := 5

// area is bound to the formula
area <- width * height

// When width or height changes, recalculate area
width = 20
area = width * height    // Recalculate
"New area: " + area -> Print</div>

        <div class="card" style="border-left: 4px solid var(--accent); margin-top: 20px;">
          <h4 style="margin-top: 0;">üí° Pro Tip: Pull vs Assignment</h4>
          <p>Use <code>:=</code> for simple one-time captures. Use <code><-</code> when you want to emphasize the data flow or capture multiple returns.</p>
          <div class="code-block">// ‚úÖ Both are valid for single returns
count := GetCount()     // Simpler
count <- GetCount()     // More explicit about data flow

// ‚úÖ Pull is required for multiple returns
x, y <- GetCoords()     // Only way to capture both</div>
        </div>
      </div>

      <div class="doc-section" id="sync">
        <h2>Sync Arrow (<->)</h2>
        
        <div class="card" style="border-left: 4px solid var(--warning); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Sync Arrow When:</h4>
          <ul class="list">
            <li>Two variables must always stay equal</li>
            <li>Model-View binding (UI updates)</li>
            <li>Mirroring state between components</li>
            <li>Creating backup/replica relationships</li>
          </ul>
        </div>
        
        <p>The sync arrow creates a bidirectional bond‚Äîwhen either side changes, the other updates automatically. <strong>Important:</strong> The sync is established for future changes; it doesn't immediately equalize the values.</p>

        <h3>Basic Sync</h3>
        <div class="code-block">model := 100
view := 50

// Establish sync (values stay as-is initially)
model <-> view

// Now changes to either update both:
view = 250
// model is now also 250

model = 999
// view is now also 999</div>

        <h3>Best Practice: Model-View Pattern</h3>
        <div class="code-block">// COMPLETE EXAMPLE: UI Sync Pattern
// Save as: model_view_sync.ouro

"=== Model-View Sync Demo ===" -> Print

// Game state (the model)
playerHealth := 100
playerScore := 0

// UI display values (the view)
healthDisplay := 100
scoreDisplay := 0

// Establish sync between model and view
playerHealth <-> healthDisplay
playerScore <-> scoreDisplay

"Initial state:" -> Print
"Health: " + playerHealth -> Print
"Score: " + playerScore -> Print

// Game logic updates the model
"" -> Print
"Player takes 30 damage..." -> Print
playerHealth = playerHealth - 30
"Health display auto-updated: " + healthDisplay -> Print

"" -> Print
"Player scores 500 points..." -> Print
playerScore = playerScore + 500
"Score display auto-updated: " + scoreDisplay -> Print

// Expected Output:
// === Model-View Sync Demo ===
// Initial state:
// Health: 100.00
// Score: 0.00
//
// Player takes 30 damage...
// Health display auto-updated: 70.00
//
// Player scores 500 points...
// Score display auto-updated: 500.00</div>

        <div class="card" style="border-left: 4px solid #e74c3c; margin-top: 20px;">
          <h4 style="margin-top: 0;">‚ö†Ô∏è Common Pitfall</h4>
          <p>Sync doesn't immediately equalize values‚Äîit only affects future changes:</p>
          <div class="code-block">a := 100
b := 50
a <-> b    // a is still 100, b is still 50!

// Only AFTER a change do they sync:
a = 75     // Now BOTH a and b are 75</div>
        </div>

        <h3>Use Cases</h3>
        <ul class="list">
          <li><strong>UI Binding</strong> ‚Äî Keep display in sync with game state</li>
          <li><strong>Multiplayer</strong> ‚Äî Mirror state between client and server</li>
          <li><strong>Backup</strong> ‚Äî Keep a backup value always current</li>
          <li><strong>Settings</strong> ‚Äî Sync config between modules</li>
        </ul>
      </div>

      <div class="doc-section" id="fork">
        <h2>Fork Arrow (-<)</h2>
        
        <div class="card" style="border-left: 4px solid #9b59b6; margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Fork Arrow When:</h4>
          <ul class="list">
            <li>Broadcasting events to multiple handlers</li>
            <li>Sending data to logging, analytics, AND storage at once</li>
            <li>Notifying multiple systems of a change</li>
            <li>Fan-out patterns (one producer, many consumers)</li>
          </ul>
        </div>
        
        <p>The fork arrow broadcasts a single value to multiple destinations simultaneously. All handlers receive the same value and execute in order.</p>

        <h3>Basic Fork</h3>
        <div class="code-block">// Send event to multiple handlers at once
event -< Logger, UI, Analytics

// Equivalent to (but cleaner than):
event -> Logger
event -> UI
event -> Analytics</div>

        <h3>Best Practice: Event Broadcasting</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Event Broadcasting
// Save as: event_broadcast.ouro

Flow LogEvent(event)
    "[LOG] " + event -> Print
    return true

Flow UpdateUI(event)
    "[UI] " + event -> Print
    return true

Flow SendAnalytics(event)
    "[ANALYTICS] " + event -> Print
    return true

"=== Event Broadcasting Demo ===" -> Print

// When a player joins, notify all systems
playerEvent := "player_joined"
playerEvent -< LogEvent, UpdateUI, SendAnalytics

"" -> Print

// When a player scores, notify all systems
scoreEvent := "player_scored"
scoreEvent -< LogEvent, UpdateUI, SendAnalytics

// Expected Output:
// === Event Broadcasting Demo ===
// [LOG] player_joined
// [UI] player_joined
// [ANALYTICS] player_joined
//
// [LOG] player_scored
// [UI] player_scored
// [ANALYTICS] player_scored</div>

        <h3>Fork with Chaining</h3>
        <p>Fork can appear at the end of a processing chain:</p>
        <div class="code-block">// Process, validate, then broadcast to multiple handlers
rawData -> Parse -> Validate -< Store, Backup, Notify</div>

        <div class="card" style="border-left: 4px solid var(--accent); margin-top: 20px;">
          <h4 style="margin-top: 0;">üí° Fork vs Multiple Forward Arrows</h4>
          <p>Fork is not just shorthand‚Äîit expresses intent clearly: "this value goes to ALL these places."</p>
          <div class="code-block">// ‚úÖ Clear intent: broadcast to all
event -< Handler1, Handler2, Handler3

// ‚ùå Less clear: are these related or separate?
event -> Handler1
event -> Handler2
event -> Handler3</div>
        </div>
      </div>

      <div class="doc-section" id="funnel">
        <h2>Funnel Arrow (>-)</h2>
        
        <div class="card" style="border-left: 4px solid var(--success); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Funnel Arrow When:</h4>
          <ul class="list">
            <li>You want to react to every change of a variable</li>
            <li>Building reactive/observer patterns</li>
            <li>Monitoring sensor values or state changes</li>
            <li>Implementing event listeners</li>
          </ul>
        </div>
        
        <p>The funnel arrow establishes an <strong>ongoing connection</strong>‚Äîwhenever the source variable changes, the handler is automatically called. This is the foundation of reactive programming in Ouroboros.</p>

        <h3>Reactive Monitoring</h3>
        <div class="code-block">// Establish a reactive connection
health >- OnHealthChanged

// Now every time health changes, OnHealthChanged is called automatically
health = 80    // Triggers OnHealthChanged(80)
health = 50    // Triggers OnHealthChanged(50)
health = 25    // Triggers OnHealthChanged(25)</div>

        <h3>Best Practice: Game State Monitoring</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Reactive Health Monitor
// Save as: health_monitor.ouro

Flow OnHealthChanged(newHealth)
    "Health changed to: " + newHealth -> Print
    if newHealth ‚â§ 25
        "‚ö†Ô∏è CRITICAL HEALTH!" -> Print
    elseif newHealth ‚â§ 50
        "‚ö° Health is low" -> Print
    return true

"=== Reactive Health Monitor ===" -> Print

health := 100
health >- OnHealthChanged    // Establish reactive connection

// Simulate taking damage
health = 75
health = 40
health = 20

// Expected Output:
// === Reactive Health Monitor ===
// Health changed to: 75.00
// Health changed to: 40.00
// ‚ö° Health is low
// Health changed to: 20.00
// ‚ö†Ô∏è CRITICAL HEALTH!</div>

        <h3>Funnel vs Forward</h3>
        <div class="code-block">// Forward: one-time push
health -> LogHealth          // Called once, right now

// Funnel: ongoing connection
health >- OnHealthChanged    // Called on EVERY future change</div>

        <div class="card" style="border-left: 4px solid var(--accent); margin-top: 20px;">
          <h4 style="margin-top: 0;">üí° When to Use Funnel vs Sync</h4>
          <p><strong>Funnel (>-)</strong>: You want to <em>react</em> to changes with custom logic<br>
          <strong>Sync (<->)</strong>: You want two variables to <em>stay equal</em></p>
          <div class="code-block">// Funnel: custom reaction
health >- UpdateHealthBar    // Call a function when health changes

// Sync: keep values equal
health <-> displayHealth     // displayHealth mirrors health</div>
        </div>
      </div>

      <div class="doc-section" id="continuous">
        <h2>Continuous Arrows (-|>, <|-)</h2>
        
        <div class="code-block">// COMPLETE EXAMPLE: Funnel Arrow (Continuous Monitoring)
// Save as: funnel_arrow.ouro

Flow ClimateMonitor(val)
    "[MONITOR] Sensor changed to: " + val -> Print
    return true

"=== Funnel Arrow Demo ==="  -> Print

sensor_temp := 22.0
sensor_pressure := 1013.0

"Initial readings:" -> Print
"Temperature: " + sensor_temp -> Print
"Pressure: " + sensor_pressure -> Print

// Establish continuous monitoring
"" -> Print
"Establishing sensor monitoring..." -> Print
sensor_temp >- ClimateMonitor

// Any change triggers the monitor
"" -> Print
"Changing temperature to 25.0..." -> Print
sensor_temp = 25.0

"" -> Print
"Changing temperature to 30.5..." -> Print
sensor_temp = 30.5

// Expected Output:
// === Funnel Arrow Demo ===
// Initial readings:
// Temperature: 22.00
// Pressure: 1013.00
//
// Establishing sensor monitoring...
//
// Changing temperature to 25.0...
// [MONITOR] Sensor changed to: 25.00
//
// Changing temperature to 30.5...
// [MONITOR] Sensor changed to: 30.50</div>
      </div>

      <div class="doc-section" id="continuous">
        <h2>Continuous Arrows (-|>, <|-, -<|)</h2>
        
        <div class="card" style="border-left: 4px solid var(--success); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Continuous Arrows When:</h4>
          <ul class="list">
            <li>Changes should automatically propagate without explicit code</li>
            <li>Building real-time data pipelines</li>
            <li>Creating derived values that auto-update</li>
          </ul>
        </div>

        <h3>Continuous Forward (-|>)</h3>
        <p>Every change to the source automatically pushes to the target:</p>
        <div class="code-block">status := "Ready"
status -|> Print    // Establish continuous forward

// Now every change auto-prints
status = "Loading..."    // Auto-printed
status = "Complete!"     // Auto-printed</div>

        <h3>Continuous Pull (<|-)</h3>
        <p>A variable that auto-updates when its source changes:</p>
        <div class="code-block">basePrice := 100
discount := 0.20

// discountedPrice auto-updates when basePrice or discount changes
discountedPrice <|- basePrice * (1 - discount)

// When basePrice changes, discountedPrice updates automatically
basePrice = 150    // discountedPrice is now 120</div>

        <h3>Continuous Fork (-<|)</h3>
        <p>Broadcast every change to multiple handlers:</p>
        <div class="code-block">health := 100

// Every time health changes, ALL handlers are called
health -<| UpdateHealthBar
health -<| CheckCriticalHealth
health -<| PlayDamageSound

health = 50    // Triggers all three handlers
health = 25    // Triggers all three handlers again</div>
      </div>

      <div class="doc-section" id="fuzzy">
        <h2>Fuzzy Arrows (~>, <~, <~>)</h2>
        
        <div class="card" style="border-left: 4px solid var(--warning); margin-bottom: 20px;">
          <h4 style="margin-top: 0;">‚úÖ Use Fuzzy Arrows When:</h4>
          <ul class="list">
            <li>Building AI with probabilistic behavior</li>
            <li>Implementing soft constraints or suggestions</li>
            <li>Modeling elastic relationships (not rigid)</li>
            <li>Creating gradual/dampened responses</li>
          </ul>
        </div>
        
        <p>Fuzzy arrows create <strong>soft influences</strong> rather than rigid assignments. The target is "suggested" rather than forced‚Äîperfect for AI, simulations, and fuzzy logic systems.</p>

        <h3>Fuzzy Forward (~>)</h3>
        <p>Suggest a value rather than force it:</p>
        <div class="code-block">temperature := 28.0

// Soft influence on controller (not a command, a suggestion)
temperature ~> ThermalController

Flow ThermalController(t)
    if t > 25.0
        "Suggesting: increase cooling" -> Print
    elseif t < 18.0
        "Suggesting: increase heating" -> Print
    else
        "Nominal" -> Print
    return true</div>

        <h3>Fuzzy Pull (<~)</h3>
        <p>Pull with noise, dampening, or probability:</p>
        <div class="code-block">// AI perception with probability
player_visibility := 0.8

// Soft pull - enemy "might" notice based on visibility
enemy_awareness <~ player_visibility

// awareness is influenced by, not equal to, visibility</div>

        <h3>Fuzzy Sync (<~>)</h3>
        <p>Bidirectional soft influence. Both sides affect each other with "elasticity":</p>
        <div class="code-block">// Market simulation: supply and demand
market_supply := 500.0
market_demand := 600.0

// Establish soft bidirectional sync
market_supply <~> market_demand

// Changes propagate with elasticity, not instantly
market_supply = 200.0
// Demand rises in response, but softly, not rigidly</div>

        <h3>Conditional Fuzzy Arrow</h3>
        <p>Combine gates with fuzzy arrows:</p>
        <div class="code-block">// Only apply fuzzy influence if windows are closed
temp -[windows_open == false]~> AC_Controller</div>
      </div>

      <div class="doc-section" id="solver">
        <h2>Solver Arrows (=>, ‚âà>)</h2>
        <p><strong>Purpose:</strong> Constraint-based solving‚Äîfind paths or solutions.</p>
        <p>Used for pathfinding, optimization, or constraint satisfaction problems.</p>

        <h3>Standard Solver (=>)</h3>
        <div class="code-block">start_position := "Sector_A"
target := "Depot"

// Request path solving
start_position => PathSolver

Flow PathSolver(start)
    "SOLVER: Computing optimal path from " -> Print
    start -> Print
    // Constraint solving logic here
    return "optimal_route"</div>

        <h3>Fuzzy Solver (‚âà>)</h3>
        <p>A soft constraint solver that finds approximate or probabilistic solutions:</p>
        <div class="code-block">// Fuzzy solver for approximate matching
input_pattern := "user_query"

// Find approximate matches
input_pattern ‚âà> FuzzyMatcher</div>
      </div>

      <div class="doc-section" id="transfer">
        <h2>Transfer Arrows (-|->, <-|-)</h2>
        <p><strong>Purpose:</strong> Move ownership‚Äîsource becomes invalid after transfer.</p>
        <p>Similar to Rust's move semantics. After transfer, the source should not be used.</p>

        <h3>Transfer Forward (-|->)</h3>
        <div class="code-block">drone_cargo := ["Titanium", "Gold", "Uranium"]

// Transfer ownership to depot
drone_cargo -|-> DepotReceiver

Flow DepotReceiver(cargo)
    "Cargo received: " -> Print
    cargo -> Print
    return true

// drone_cargo is now conceptually invalid</div>

        <h3>Transfer Pull (<-|-)</h3>
        <p>Pull value and take ownership from source:</p>
        <div class="code-block">source_data := "Critical Data"

// Pull and take ownership
my_data <-|- source_data

// source_data is now invalid, my_data owns the value</div>
      </div>

      <div class="doc-section" id="sever">
        <h2>Sever Arrows (-||->, <-||-)</h2>
        <p><strong>Purpose:</strong> Explicitly break a connection or trigger disconnect.</p>
        <p>Used to signal the end of a relationship or connection.</p>

        <h3>Sever Forward (-||->)</h3>
        <div class="code-block">session_id := "Session_12345"

// Sever the connection
session_id -||-> DisconnectHandler

Flow DisconnectHandler(id)
    "Disconnecting session: " -> Print
    id -> Print
    "Connection severed." -> Print
    return true</div>

        <h3>Sever Pull (<-||-)</h3>
        <p>Pull final value and disconnect from source:</p>
        <div class="code-block">stream_value := 42

// Pull the current value and disconnect
final_value <-||- stream_value

// No longer connected to stream_value</div>
      </div>

      <div class="doc-section" id="async">
        <h2>Async Arrows</h2>
        <p>Async variants allow fire-and-forget or non-blocking operations.</p>

        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>->></code></td><td>Async Forward</td><td>Fire-and-forget forward</td></tr>
            <tr><td><code><<-</code></td><td>Async Pull</td><td>Non-blocking capture</td></tr>
            <tr><td><code><<->></code></td><td>Async Sync</td><td>Non-blocking bidirectional sync</td></tr>
            <tr><td><code>-<<</code></td><td>Async Fork</td><td>Parallel broadcast</td></tr>
            <tr><td><code>>>-</code></td><td>Async Funnel</td><td>Async continuous stream</td></tr>
            <tr><td><code>->|</code></td><td>Await Forward</td><td>Wait then forward</td></tr>
            <tr><td><code>|<-</code></td><td>Pull Await</td><td>Wait for value to be ready</td></tr>
          </tbody>
        </table>

        <h3>Async Forward (->>)</h3>
        <p>Fire-and-forget: The flow executes in a separate thread while the main script continues immediately.</p>
        <div class="code-block">Flow SlowProcess(msg)
    // Simulating slow work
    "[SlowProcess] Got: " + msg -> Print

// Async forward - continues immediately
"AsyncMessage" ->> SlowProcess
"(This line may print BEFORE the async output above)" -> Print</div>

        <h3>Async Fork (-<<)</h3>
        <p>Broadcast to multiple handlers in parallel. Each handler runs in its own thread.</p>
        <div class="code-block">Flow Handler1(val)
    "[Handler1] " + val -> Print
    return true

Flow Handler2(val)
    "[Handler2] " + val -> Print
    return true

Flow Handler3(val)
    "[Handler3] " + val -> Print
    return true

counter := 0

// Async fork - all handlers run in parallel
"Broadcast" -<< Handler1, Handler2, Handler3
"Counter immediately after async fork: " + counter -> Print
// Counter will be 0 (handlers haven't finished yet)</div>

        <h3>Async vs Sync Comparison</h3>
        <div class="code-block">// Sync forward chain - waits for each step
counter := 0
"start" -> A -> B -> C
"Counter after sync: " + counter -> Print  // Counter = 3

// Async forward chain - fires immediately
counter := 0
"start" ->> A
"start" ->> B
"start" ->> C
"Counter after async: " + counter -> Print  // Counter = 0 (async not done)</div>

        <h3>Await Forward (->|)</h3>
        <p>Wait for a value or condition to be ready before forwarding:</p>
        <div class="code-block">// Wait for value to be ready, then forward
data ->| AsyncProcessor</div>

        <h3>Pull Await (|<-)</h3>
        <p>Wait for conditions to be true before pulling:</p>
        <div class="code-block">// Wait for all conditions
launch_signal |<- fuel_ready
launch_signal |<- nav_ready
launch_signal |<- crew_ready</div>
      </div>

      <div class="doc-section" id="conditional-arrows">
        <h2>Conditional Pull & Sync Arrows</h2>
        <p><strong>Purpose:</strong> Pull or sync data only when a condition is met, with optional transformation.</p>
        <p>These arrows use bracket notation to embed conditions directly in the arrow.</p>

        <h3>Conditional Pull (<-[condition]-)</h3>
        <p>Only pull the value if the condition is true:</p>
        <div class="code-block">is_daytime := true
solar_reading := 500.0
solar_output := 0.0

// Only pull if daytime
solar_output <-[is_daytime]- solar_reading

// With negation
solar_output <-[!is_daytime]- 0.0</div>

        <h3>Conditional Pull with Transformation</h3>
        <p>Transform the value before pulling:</p>
        <div class="code-block">efficiency := 0.8
raw_reading := 100.0
adjusted := 0.0

// Syntax: target <-[condition ? transformation]- source
adjusted <-[is_daytime ? raw_reading * efficiency]- raw_reading</div>

        <h3>Conditional Sync (<-[condition]->)</h3>
        <p>Only sync if the condition is met. Perfect for secure or conditional synchronization:</p>
        <div class="code-block">local_log := "System Status: Online"
remote_hq := "Standby"
is_secure := true

// Only sync if connection is secure
// Syntax: target <-[condition]-> source
remote_hq <-[is_secure]-> local_log

// If not secure, sync is blocked
is_secure = false
// Now changes won't propagate to remote_hq</div>

        <h3>Real-World Example: Power Grid Controller</h3>
        <div class="code-block">// Priority-based source selection using conditional pulls
solar := 500.0
battery := 300.0
grid := 1000.0
demand := 450.0

active_source := "None"
power := 0.0

// Priority 1: Solar (if sufficient)
use_solar := solar >= demand
power <-[use_solar]- solar
active_source <-[use_solar]- "Solar"

// Priority 2: Battery (if solar fails)
use_battery := !use_solar & battery >= demand
power <-[use_battery]- battery
active_source <-[use_battery]- "Battery"

// Priority 3: Grid (fallback)
use_grid := !use_solar & !use_battery
power <-[use_grid]- grid
active_source <-[use_grid]- "Grid"</div>
      </div>

      <div class="doc-section" id="gates">
        <h2>Conditional Gates</h2>
        <p>Gates filter or transform data inline using <code>-[condition]-></code> syntax.</p>

        <h3>Simple Gate (Filter)</h3>
        <p>Only execute if condition is true:</p>
        <div class="code-block">value := 75

// Only calls ProcessHigh if value > 50
value -[value > 50]-> ProcessHigh

// Only calls ProcessLow if value ‚â§ 50
value -[value ‚â§ 50]-> ProcessLow</div>

        <h3>Transform Gate</h3>
        <p>Transform the value before passing:</p>
        <div class="code-block">input := 10

// If condition is true, pass the transformed value
input -[input > 5 ? input * 2]-> Handler     // Passes 20
input -[input > 5 ? "HIGH"]-> Classifier     // Passes "HIGH"</div>

        <h3>Complex Conditions</h3>
        <div class="code-block">status := "Active"
power := 80

// Compound conditions
status -[status == "Active" & power > 90]-> CriticalHandler
status -[status == "Active" & (power > 90 | power < 10)]-> AlertHandler</div>

        <h3>Gates with Any Arrow</h3>
        <div class="code-block">// Gate + Fuzzy
temp -[lockdown == false]~> Regulator

// Gate + Solver
position -[obstacles < 5]=> PathFinder</div>

        <h3>If-Else Pattern with Gates</h3>
        <p>Gates provide a powerful alternative to traditional if/else statements. Use complementary conditions for mutually exclusive branches:</p>
        
        <div class="code-block">// Traditional if/else:
if (score ‚â• 60)
    "Pass" -> Print
else
    "Fail" -> Print

// Gate equivalent (flow-oriented):
score -[score ‚â• 60]-> Print("Pass")
score -[score < 60]-> Print("Fail")</div>

        <h4>Multi-Branch (If/Elseif/Else)</h4>
        <div class="code-block">// Traditional elseif chain:
if (level > 90)
    status := "Expert"
elseif (level > 50)
    status := "Intermediate"
else
    status := "Beginner"

// Gate equivalent with ranges:
level -[level > 90 ? "Expert"]-> status
level -[level > 50 & level ‚â§ 90 ? "Intermediate"]-> status
level -[level ‚â§ 50 ? "Beginner"]-> status</div>

        <h4>Nested Conditions</h4>
        <div class="code-block">// Nested if/else:
if (online)
    if (admin)
        "Full Access" -> Print
    else
        "User Access" -> Print
else
    "Offline" -> Print

// Flattened with compound gates:
status -[online & admin]-> Print("Full Access")
status -[online & !admin]-> Print("User Access")
status -[!online]-> Print("Offline")</div>

        <h4>Routing to Different Flows</h4>
        <div class="code-block">// Route based on type
message -[type == "error"]-> HandleError
message -[type == "warning"]-> HandleWarning
message -[type == "info"]-> HandleInfo
message -[type == "debug" & debug_mode]-> HandleDebug</div>

        <h4>Calling Flows with :: and ||</h4>
        <p>The <code>::</code> operator acts as "then" (success handler), and <code>||</code> acts as "else" (failure handler):</p>
        <div class="code-block">// Full gate syntax:
// -[condition ? action :: onSuccess || onFailure]-
// 
// ?  = action to run if condition true (before main flow)
// :: = success handler (like "then")
// || = failure handler (like "else" or "catch")

// Example: Validate before processing
Flow IsValid(x)
    return x > 0

Flow Process(x)
    "Processing: " + x -> Print

Flow Reject(x)
    "Rejected: " + x -> Print

// If IsValid returns true, call Process; otherwise Reject
value := 42
value -[IsValid(value) :: Process(value) || Reject(value)]-

// With pre-action
data -[CheckAuth(user) ? Log("Checking") :: Allow(user) || Deny(user)]-</div>

        <h4>Practical If-Else-Error Pattern</h4>
        <div class="code-block">// Traditional approach:
if (HasPermission(user))
    if (ValidateData(input))
        ProcessRequest(input)
        Log("Success")
    else
        Log("Invalid data")
else
    Log("Access denied")

// Gate approach with ::  and ||
input -[HasPermission(user) & ValidateData(input) :: ProcessRequest(input) || HandleFailure(input)]-

// Or split into multiple gates:
request -[!HasPermission(user) || Log("Access denied")]-
request -[!ValidateData(input) || Log("Invalid data")]-  
request -[HasPermission(user) & ValidateData(input) :: ProcessRequest(input)]-</div>

        <h4>When Gates Excel</h4>
        <ul class="list">
          <li><strong>Parallel evaluation</strong> ‚Äî All gates checked independently</li>
          <li><strong>Data transformation</strong> ‚Äî Use <code>?</code> to change values inline</li>
          <li><strong>Flow orchestration</strong> ‚Äî Use <code>::</code> for success, <code>||</code> for failure handlers</li>
          <li><strong>Pipeline integration</strong> ‚Äî Chain with other arrows seamlessly</li>
          <li><strong>Visual clarity</strong> ‚Äî See all conditions at the same indentation level</li>
        </ul>
      </div>

      <div class="doc-section" id="chaining">
        <h2>Arrow Chaining</h2>
        <p>Combine multiple arrows in a single expression for complex pipelines.</p>

        <h3>Basic Chain</h3>
        <div class="code-block">input -> Step1 -> Step2 -> Step3 -> Print</div>

        <h3>Capture from Chain</h3>
        <div class="code-block">// Chain flows and capture result
result <- Transform(input)
result <- input -> Transform -> Validate</div>

        <h3>Mixed Arrow Chain</h3>
        <div class="code-block">// Gate -> Flow -> Fuzzy -> Solver -> Fork
data -[valid]-> Decrypt ~> Analyze => Solve -< Log, Alert</div>

        <h3>The "Omega Chain"</h3>
        <p>Maximum complexity‚Äîcombining all arrow types:</p>
        <div class="code-block">// 1. Gate check on radiation
// 2. Forward to Decrypt
// 3. Fuzzy to Analyzer
// 4. Solver for geometry
// 5. Fork to multiple outputs

artifact -[radiation < 10]-> Decrypt ~> Analyzer => Solver -< Log, Alert</div>
      </div>
    </main>
  </div>

  <footer>
    <p>Ouroboros Language ¬© 2026</p>
  </footer>

  <script>
    // Add copy buttons to all code blocks
    document.addEventListener('DOMContentLoaded', function() {
      const codeBlocks = document.querySelectorAll('.code-block');
      
      codeBlocks.forEach((block, index) => {
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block-wrapper';
        block.parentNode.insertBefore(wrapper, block);
        wrapper.appendChild(block);
        
        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.setAttribute('data-code-index', index);
        
        wrapper.appendChild(copyBtn);
        
        // Copy functionality
        copyBtn.addEventListener('click', function() {
          const code = block.textContent;
          navigator.clipboard.writeText(code).then(() => {
            // Show success state
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.classList.remove('copied');
            }, 2000);
          }).catch(err => {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
            }, 2000);
          });
        });
      });
    });
  </script>
  <script src="search.js"></script>
</body>
</html>
