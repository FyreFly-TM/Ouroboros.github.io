<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arrow Reference - Ouroboros</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    <div class="nav-inner">
      <a href="index.html" class="brand"><img src="OuroborosLogo.png" alt="Ouroboros" class="logo">Ouroboros</a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="getting_started.html">Get Started</a>
        <a href="examples.html">Examples</a>
        <a href="flows.html">Flows</a>
        <a href="reference.html">Reference</a>
        <a href="arrows.html">Arrows</a>
        <a href="tokens.html">Tokens</a>
        <a href="files.html">Files</a>
        <a href="stdlib.html">Std Lib</a>
        <a href="downloads.html">Downloads</a>
      </div>
    </div>
  </nav>

  <div class="doc-layout">
    <aside class="doc-panel toc">
      <h3>Arrow Types</h3>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#forward">Forward (->)</a></li>
        <li><a href="#pull">Pull (<-)</a></li>
        <li><a href="#sync">Sync (<->)</a></li>
        <li><a href="#fork">Fork (-<, -◁)</a></li>
        <li><a href="#funnel">Funnel (>-, ▷-)</a></li>
        <li><a href="#continuous">Continuous (-▷, ◁-, ◁-▷)</a></li>
        <li><a href="#fuzzy">Fuzzy (~>, <~, <~>)</a></li>
        <li><a href="#solver">Solver (=>, ≈>)</a></li>
        <li><a href="#transfer">Transfer (-|->, <-|-)</a></li>
        <li><a href="#sever">Sever (-||->, <-||-)</a></li>
        <li><a href="#async">Async Arrows</a></li>
        <li><a href="#conditional-arrows">Conditional Arrows</a></li>
        <li><a href="#gates">Conditional Gates</a></li>
        <li><a href="#chaining">Arrow Chaining</a></li>
      </ul>
    </aside>

    <main class="doc-panel doc-content">
      <div class="doc-header">
        <div class="badge">Language Reference</div>
        <h1>Arrow Semantics</h1>
        <p>Arrows are the heart of Ouroboros. Every arrow expresses a specific data flow intent.</p>
      </div>

      <div class="doc-section" id="overview">
        <h2>Overview</h2>
        <p>Ouroboros uses arrows to direct data flow between expressions, variables, and flows. Each arrow type conveys different semantics:</p>
        
        <h3>Core Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Direction</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>-></code></td><td>Forward</td><td>Left → Right</td><td>Push data to a destination</td></tr>
            <tr><td><code><-</code></td><td>Pull</td><td>Right → Left</td><td>Capture or bind reactively</td></tr>
            <tr><td><code><-></code></td><td>Sync</td><td>Bidirectional</td><td>Keep both sides equal</td></tr>
            <tr><td><code>-<</code></td><td>Fork</td><td>One → Many</td><td>Broadcast to multiple targets</td></tr>
          </tbody>
        </table>

        <h3>Continuous/Streaming Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>>-</code></td><td>Funnel</td><td>Stream changes reactively to handler</td></tr>
            <tr><td><code>▷-</code></td><td>Funnel (Unicode)</td><td>Same as >- with Unicode symbol</td></tr>
            <tr><td><code>-▷</code></td><td>Continuous Forward</td><td>Push continuously</td></tr>
            <tr><td><code>◁-</code></td><td>Continuous Pull</td><td>Continuously monitor and pull changes</td></tr>
            <tr><td><code>◁-▷</code></td><td>Continuous Sync</td><td>Bidirectional continuous sync</td></tr>
            <tr><td><code>-◁</code></td><td>Continuous Fork</td><td>Fork to multiple targets on every change</td></tr>
          </tbody>
        </table>

        <h3>Special Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>~></code></td><td>Fuzzy Forward</td><td>Suggest rather than force (soft influence)</td></tr>
            <tr><td><code><~</code></td><td>Fuzzy Pull</td><td>Softly pull with noise/dampening</td></tr>
            <tr><td><code><~></code></td><td>Fuzzy Sync</td><td>Bidirectional soft influence</td></tr>
            <tr><td><code>=></code></td><td>Solver</td><td>Find solutions/paths (constraint-based)</td></tr>
            <tr><td><code>≈></code></td><td>Fuzzy Solver</td><td>Soft constraint solving</td></tr>
          </tbody>
        </table>

        <h3>Ownership Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>-|-></code></td><td>Transfer Forward</td><td>Move data, invalidate source</td></tr>
            <tr><td><code><-|-</code></td><td>Transfer Pull</td><td>Pull and take ownership, source invalidated</td></tr>
            <tr><td><code>-||-></code></td><td>Sever Forward</td><td>Break connection, forward final value</td></tr>
            <tr><td><code><-||-</code></td><td>Sever Pull</td><td>Pull and disconnect from source</td></tr>
          </tbody>
        </table>

        <h3>Conditional Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code><-[cond]-</code></td><td>Conditional Pull</td><td>Pull only if condition is true</td></tr>
            <tr><td><code><-[cond]-></code></td><td>Conditional Sync</td><td>Sync only if condition is true</td></tr>
            <tr><td><code>-[cond]-></code></td><td>Conditional Forward</td><td>Forward only if condition is true</td></tr>
          </tbody>
        </table>

        <h3>Async Arrows</h3>
        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>->></code></td><td>Async Forward</td><td>Fire-and-forget forward</td></tr>
            <tr><td><code><<-</code></td><td>Async Pull</td><td>Non-blocking capture</td></tr>
            <tr><td><code><<->></code></td><td>Async Sync</td><td>Non-blocking bidirectional</td></tr>
            <tr><td><code>-<<</code></td><td>Async Fork</td><td>Parallel broadcast</td></tr>
            <tr><td><code>>>-</code></td><td>Async Funnel</td><td>Async continuous stream</td></tr>
            <tr><td><code>->|</code></td><td>Await Forward</td><td>Wait then forward</td></tr>
            <tr><td><code>|<-</code></td><td>Pull Await</td><td>Wait for value to be ready</td></tr>
            <tr><td><code>|<->|</code></td><td>Sync Await</td><td>Wait for both sides to be ready</td></tr>
            <tr><td><code><-|-></code></td><td>Sync Transfer</td><td>Transfer ownership bidirectionally</td></tr>
            <tr><td><code><-||-></code></td><td>Sync Sever</td><td>Sever bidirectional connection</td></tr>
          </tbody>
        </table>
      </div>

      <div class="doc-section" id="forward">
        <h2>Forward Arrow (->)</h2>
        <p><strong>Purpose:</strong> Push data from left to right.</p>
        <p>The most common arrow. It sends values to flows, chains operations, or passes arguments.</p>
        
        <h3>Basic Usage</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Forward Arrow
// Save as: forward_arrow.ouro

Flow ProcessNumber(n)
    "Processing: " + n -> Print
    result := n * 2
    return result

"=== Forward Arrow Demo ==="  -> Print

// Send a value to Print
"Hello, World!" -> Print
"" -> Print

// Pass to a flow
"Sending 42 to ProcessNumber:" -> Print
42 -> ProcessNumber
"Result: " + result -> Print

// Expected Output:
// === Forward Arrow Demo ===
// Hello, World!
//
// Sending 42 to ProcessNumber:
// Processing: 42.00
// Result: 84.00</div>

        <h3>Multiple Arguments</h3>
        <div class="code-block">// Pass multiple values separated by commas
10, 5 -> Add -> Print</div>

        <h3>Chaining</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Forward Arrow Chaining
// Save as: arrow_chain.ouro

Flow Validate(data)
    "[Validate] " + data -> Print
    return data

Flow Transform(data)
    "[Transform] " + data -> Print
    result := data + "_modified"
    return result

Flow Store(data)
    "[Store] " + data -> Print
    return true

"=== Arrow Chaining Demo ==="  -> Print

// Step by step chain
input := "raw_data"
Validate(input)
Transform(result)
Store(result)

// Expected Output:
// === Arrow Chaining Demo ===
// [Validate] raw_data
// [Transform] raw_data
// [Store] raw_data_modified</div>
      </div>

      <div class="doc-section" id="pull">
        <h2>Pull Arrow (<-)</h2>
        <p><strong>Purpose:</strong> Capture return values or create reactive bindings.</p>

        <h3>Capture Return Value</h3>
        <div class="code-block">// COMPLETE EXAMPLE: Pull Arrow Capture
// Save as: pull_capture.ouro

Flow Add(a, b)
    sum := a + b
    return sum

Flow Divide(a, b)
    quotient := a / b
    remainder := a % b
    return quotient, remainder

"=== Pull Arrow Demo ==="  -> Print

// Capture single return using :=
result := Add(10, 5)
"Add(10, 5) = " + result -> Print

// Or use pull arrow with function call
result <- Add(20, 30)
"Add(20, 30) = " + result -> Print

// Capture multiple returns
"" -> Print
"Divide(17, 5):" -> Print
q, r <- Divide(17, 5)
"Quotient: " + q -> Print
"Remainder: " + r -> Print

// Expected Output:
// === Pull Arrow Demo ===
// Add(10, 5) = 15.00
// Add(20, 30) = 50.00
//
// Divide(17, 5):
// Quotient: 3.40
// Remainder: 2.00</div>

        <h3>Reactive Binding</h3>
        <p>When used with an expression, the left side updates whenever the right side changes:</p>
        <div class="code-block">// COMPLETE EXAMPLE: Reactive Binding
// Save as: reactive.ouro

width := 10
height := 5

// area automatically recalculates when width or height change
area := width * height

"=== Reactive Binding Demo ==="  -> Print
"Initial width: " + width -> Print
"Initial height: " + height -> Print
"Calculated area: " + area -> Print

"" -> Print
"Changing width to 20..." -> Print
width = 20
area = width * height
"New area: " + area -> Print

"" -> Print
"Changing height to 10..." -> Print
height = 10
area = width * height
"New area: " + area -> Print

// Expected Output:
// === Reactive Binding Demo ===
// Initial width: 10.00
// Initial height: 5.00
// Calculated area: 50.00
//
// Changing width to 20...
// New area: 200.00
//
// Changing height to 10...
// New area: 200.00</div>

        <h3>Formula Binding</h3>
        <div class="code-block">co2 := 400.0
temp := -50.0
water := 10.0

// Complex formula binding
health <- (temp + 50.0) * water / co2</div>
      </div>

      <div class="doc-section" id="sync">
        <h2>Sync Arrow (<->)</h2>
        <p><strong>Purpose:</strong> Bidirectional binding—both sides stay equal when either changes.</p>
        <p>Creates a reactive binding where changes to either side are reflected in the other. <strong>Important:</strong> The sync arrow does not immediately copy values when established—it only takes effect when either variable is later changed.</p>

        <div class="code-block">// COMPLETE EXAMPLE: Sync Arrow (Bidirectional Binding)
// Save as: sync_arrow.ouro

"=== Sync Arrow Demo ==="  -> Print

model := 100
view := 50

"Initial values:" -> Print
"model = " + model -> Print
"view = " + view -> Print

// Establish sync binding (values remain unchanged initially)
model <-> view
"" -> Print
"After sync binding (no immediate change):" -> Print
"model = " + model -> Print
"view = " + view -> Print

// Now when either changes, the other follows
"" -> Print
"Setting view = 250..." -> Print
view = 250
"model = " + model -> Print
"view = " + view -> Print

"" -> Print
"Setting model = 999..." -> Print
model = 999
"model = " + model -> Print
"view = " + view -> Print

// Expected Output:
// === Sync Arrow Demo ===
// Initial values:
// model = 100.00
// view = 50.00
//
// After sync binding (no immediate change):
// model = 100.00
// view = 50.00
//
// Setting view = 250...
// model = 250.00
// view = 250.00
//
// Setting model = 999...
// model = 999.00
// view = 999.00</div>

        <h3>Use Cases</h3>
        <ul class="list">
          <li>Model-View synchronization in UI</li>
          <li>Game state between client and server</li>
          <li>Keeping backup values in sync</li>
        </ul>
      </div>

      <div class="doc-section" id="fork">
        <h2>Fork Arrow (-<)</h2>
        <p><strong>Purpose:</strong> Send a single input to multiple destinations.</p>
        <p>Broadcasting—one source feeds many targets simultaneously.</p>

        <div class="code-block">// COMPLETE EXAMPLE: Fork Arrow
// Save as: fork_arrow.ouro

Flow LogEvent(event)
    "[LOG] " + event -> Print
    return true

Flow UpdateUI(event)
    "[UI] Updating display: " + event -> Print
    return true

Flow NotifyUser(event)
    "[NOTIFY] Alert: " + event -> Print
    return true

"=== Fork Arrow Demo ==="  -> Print
"Sending 'player_joined' to multiple handlers..." -> Print
"" -> Print

// Fork to multiple handlers
event := "player_joined"
event -< LogEvent, UpdateUI, NotifyUser

"" -> Print
"Sending 'game_started' to multiple handlers..." -> Print
"" -> Print

event2 := "game_started"
event2 -< LogEvent, UpdateUI, NotifyUser

// Expected Output:
// === Fork Arrow Demo ===
// Sending 'player_joined' to multiple handlers...
//
// [LOG] player_joined
// [UI] Updating display: player_joined
// [NOTIFY] Alert: player_joined
//
// Sending 'game_started' to multiple handlers...
//
// [LOG] game_started
// [UI] Updating display: game_started
// [NOTIFY] Alert: game_started</div>

        <h3>Chained Forks</h3>
        <p>Forks can appear at the end of arrow chains:</p>
        <div class="code-block">// Process then fork the result
data -> Transform -> Validate -< Store, Backup, Notify</div>

        <h3>Continuous Fork (-◁)</h3>
        <p>Combine continuous monitoring with forking—every change broadcasts to all targets:</p>
        <div class="code-block">health := 100

// Every time health changes, all handlers are called
health -◁ UpdateHealthBar
health -◁ CheckCriticalHealth
health -◁ UpdateDamageOverlay

health = 50  // Triggers all three handlers</div>
      </div>

      <div class="doc-section" id="funnel">
        <h2>Funnel Arrows (>-, ▷-)</h2>
        <p><strong>Purpose:</strong> Stream data continuously—any change triggers the target.</p>
        <p>Unlike a one-time forward arrow, a funnel establishes an ongoing connection. Use <code>>-</code> for ASCII or <code>▷-</code> for Unicode.</p>

        <div class="code-block">// COMPLETE EXAMPLE: Funnel Arrow (Continuous Monitoring)
// Save as: funnel_arrow.ouro

Flow ClimateMonitor(val)
    "[MONITOR] Sensor changed to: " + val -> Print
    return true

"=== Funnel Arrow Demo ==="  -> Print

sensor_temp := 22.0
sensor_pressure := 1013.0

"Initial readings:" -> Print
"Temperature: " + sensor_temp -> Print
"Pressure: " + sensor_pressure -> Print

// Establish continuous monitoring
"" -> Print
"Establishing sensor monitoring..." -> Print
sensor_temp >- ClimateMonitor

// Any change triggers the monitor
"" -> Print
"Changing temperature to 25.0..." -> Print
sensor_temp = 25.0

"" -> Print
"Changing temperature to 30.5..." -> Print
sensor_temp = 30.5

// Expected Output:
// === Funnel Arrow Demo ===
// Initial readings:
// Temperature: 22.00
// Pressure: 1013.00
//
// Establishing sensor monitoring...
//
// Changing temperature to 25.0...
// [MONITOR] Sensor changed to: 25.00
//
// Changing temperature to 30.5...
// [MONITOR] Sensor changed to: 30.50</div>
      </div>

      <div class="doc-section" id="continuous">
        <h2>Continuous Arrows (-▷, ◁-)</h2>
        <p><strong>Purpose:</strong> Establish ongoing push or pull connections.</p>
        <p>These arrows maintain a persistent connection—any change automatically propagates.</p>

        <h3>Continuous Forward (-▷)</h3>
        <p>Continuously push updates to the target:</p>
        <div class="code-block">msg := "Status Update"

// Continuously forward to Print
msg -▷ Print

// Every change to msg is automatically printed
msg = "New Status"  // Printed automatically</div>

        <h3>Continuous Pull (◁-)</h3>
        <p>Continuously monitor a source and pull changes:</p>
        <div class="code-block">source_value := 100

// Establish continuous pull
monitored ◁- source_value

// monitored updates whenever source_value changes
source_value = 200  // monitored is now 200</div>
      </div>

      <div class="doc-section" id="fuzzy">
        <h2>Fuzzy Arrows (~>, <~, <~>)</h2>
        <p><strong>Purpose:</strong> Soft influence—suggest rather than force.</p>
        <p>Used for fuzzy logic systems where values are "influenced" rather than directly set. The relationship is probabilistic or soft, not rigid.</p>

        <h3>Fuzzy Forward (~>)</h3>
        <p>Softly push influence to a target:</p>
        <div class="code-block">temperature := 28.0

// Fuzzy influence on controller
temperature ~> ThermalController

Flow ThermalController(t)
    // Fuzzy logic: soft response
    if t > 25.0
        "Suggesting: increase cooling" -> Print
    elseif t < 18.0
        "Suggesting: increase heating" -> Print
    else
        "Nominal range" -> Print
    return true</div>

        <h3>Fuzzy Pull (<~)</h3>
        <p>Softly pull influence from a source. The value received may be noisy or dampened:</p>
        <div class="code-block">// AI perception with probability
player_visibility := 0.8  // 0.0 to 1.0
enemy_alert_level := 0.0

// Soft pull - enemy "might" see based on visibility
enemy_alert_level <~ player_visibility

// Alert level is influenced by, not strictly set to, visibility</div>

        <h3>Fuzzy Sync (<~>)</h3>
        <p>Bidirectional soft influence. Both sides affect each other with "elasticity":</p>
        <div class="code-block">// Market simulation: supply and demand
market_supply := 500.0
market_demand := 600.0

// Establish soft bidirectional sync
market_supply <~> market_demand

// Changes propagate with elasticity, not instantly
market_supply = 200.0
// Demand rises in response, but softly, not rigidly</div>

        <h3>Conditional Fuzzy Arrow</h3>
        <p>Combine gates with fuzzy arrows:</p>
        <div class="code-block">// Only apply fuzzy influence if windows are closed
temp -[windows_open == false]~> AC_Controller</div>
      </div>

      <div class="doc-section" id="solver">
        <h2>Solver Arrows (=>, ≈>)</h2>
        <p><strong>Purpose:</strong> Constraint-based solving—find paths or solutions.</p>
        <p>Used for pathfinding, optimization, or constraint satisfaction problems.</p>

        <h3>Standard Solver (=>)</h3>
        <div class="code-block">start_position := "Sector_A"
target := "Depot"

// Request path solving
start_position => PathSolver

Flow PathSolver(start)
    "SOLVER: Computing optimal path from " -> Print
    start -> Print
    // Constraint solving logic here
    return "optimal_route"</div>

        <h3>Fuzzy Solver (≈>)</h3>
        <p>A soft constraint solver that finds approximate or probabilistic solutions:</p>
        <div class="code-block">// Fuzzy solver for approximate matching
input_pattern := "user_query"

// Find approximate matches
input_pattern ≈> FuzzyMatcher</div>
      </div>

      <div class="doc-section" id="transfer">
        <h2>Transfer Arrows (-|->, <-|-)</h2>
        <p><strong>Purpose:</strong> Move ownership—source becomes invalid after transfer.</p>
        <p>Similar to Rust's move semantics. After transfer, the source should not be used.</p>

        <h3>Transfer Forward (-|->)</h3>
        <div class="code-block">drone_cargo := ["Titanium", "Gold", "Uranium"]

// Transfer ownership to depot
drone_cargo -|-> DepotReceiver

Flow DepotReceiver(cargo)
    "Cargo received: " -> Print
    cargo -> Print
    return true

// drone_cargo is now conceptually invalid</div>

        <h3>Transfer Pull (<-|-)</h3>
        <p>Pull value and take ownership from source:</p>
        <div class="code-block">source_data := "Critical Data"

// Pull and take ownership
my_data <-|- source_data

// source_data is now invalid, my_data owns the value</div>
      </div>

      <div class="doc-section" id="sever">
        <h2>Sever Arrows (-||->, <-||-)</h2>
        <p><strong>Purpose:</strong> Explicitly break a connection or trigger disconnect.</p>
        <p>Used to signal the end of a relationship or connection.</p>

        <h3>Sever Forward (-||->)</h3>
        <div class="code-block">session_id := "Session_12345"

// Sever the connection
session_id -||-> DisconnectHandler

Flow DisconnectHandler(id)
    "Disconnecting session: " -> Print
    id -> Print
    "Connection severed." -> Print
    return true</div>

        <h3>Sever Pull (<-||-)</h3>
        <p>Pull final value and disconnect from source:</p>
        <div class="code-block">stream_value := 42

// Pull the current value and disconnect
final_value <-||- stream_value

// No longer connected to stream_value</div>
      </div>

      <div class="doc-section" id="async">
        <h2>Async Arrows</h2>
        <p>Async variants allow fire-and-forget or non-blocking operations.</p>

        <table class="table">
          <thead>
            <tr><th>Arrow</th><th>Name</th><th>Purpose</th></tr>
          </thead>
          <tbody>
            <tr><td><code>->></code></td><td>Async Forward</td><td>Fire-and-forget forward</td></tr>
            <tr><td><code><<-</code></td><td>Async Pull</td><td>Non-blocking capture</td></tr>
            <tr><td><code><<->></code></td><td>Async Sync</td><td>Non-blocking bidirectional sync</td></tr>
            <tr><td><code>-<<</code></td><td>Async Fork</td><td>Parallel broadcast</td></tr>
            <tr><td><code>>>-</code></td><td>Async Funnel</td><td>Async continuous stream</td></tr>
            <tr><td><code>->|</code></td><td>Await Forward</td><td>Wait then forward</td></tr>
            <tr><td><code>|<-</code></td><td>Pull Await</td><td>Wait for value to be ready</td></tr>
          </tbody>
        </table>

        <h3>Async Forward (->>)</h3>
        <p>Fire-and-forget: The flow executes in a separate thread while the main script continues immediately.</p>
        <div class="code-block">Flow SlowProcess(msg)
    // Simulating slow work
    "[SlowProcess] Got: " + msg -> Print

// Async forward - continues immediately
"AsyncMessage" ->> SlowProcess
"(This line may print BEFORE the async output above)" -> Print</div>

        <h3>Async Fork (-<<)</h3>
        <p>Broadcast to multiple handlers in parallel. Each handler runs in its own thread.</p>
        <div class="code-block">Flow Handler1(val)
    "[Handler1] " + val -> Print
    return true

Flow Handler2(val)
    "[Handler2] " + val -> Print
    return true

Flow Handler3(val)
    "[Handler3] " + val -> Print
    return true

counter := 0

// Async fork - all handlers run in parallel
"Broadcast" -<< Handler1, Handler2, Handler3
"Counter immediately after async fork: " + counter -> Print
// Counter will be 0 (handlers haven't finished yet)</div>

        <h3>Async vs Sync Comparison</h3>
        <div class="code-block">// Sync forward chain - waits for each step
counter := 0
"start" -> A -> B -> C
"Counter after sync: " + counter -> Print  // Counter = 3

// Async forward chain - fires immediately
counter := 0
"start" ->> A
"start" ->> B
"start" ->> C
"Counter after async: " + counter -> Print  // Counter = 0 (async not done)</div>

        <h3>Await Forward (->|)</h3>
        <p>Wait for a value or condition to be ready before forwarding:</p>
        <div class="code-block">// Wait for value to be ready, then forward
data ->| AsyncProcessor</div>

        <h3>Pull Await (|<-)</h3>
        <p>Wait for conditions to be true before pulling:</p>
        <div class="code-block">// Wait for all conditions
launch_signal |<- fuel_ready
launch_signal |<- nav_ready
launch_signal |<- crew_ready</div>
      </div>

      <div class="doc-section" id="conditional-arrows">
        <h2>Conditional Pull & Sync Arrows</h2>
        <p><strong>Purpose:</strong> Pull or sync data only when a condition is met, with optional transformation.</p>
        <p>These arrows use bracket notation to embed conditions directly in the arrow.</p>

        <h3>Conditional Pull (<-[condition]-)</h3>
        <p>Only pull the value if the condition is true:</p>
        <div class="code-block">is_daytime := true
solar_reading := 500.0
solar_output := 0.0

// Only pull if daytime
solar_output <-[is_daytime]- solar_reading

// With negation
solar_output <-[!is_daytime]- 0.0</div>

        <h3>Conditional Pull with Transformation</h3>
        <p>Transform the value before pulling:</p>
        <div class="code-block">efficiency := 0.8
raw_reading := 100.0
adjusted := 0.0

// Syntax: target <-[condition ? transformation]- source
adjusted <-[is_daytime ? raw_reading * efficiency]- raw_reading</div>

        <h3>Conditional Sync (<-[condition]->)</h3>
        <p>Only sync if the condition is met. Perfect for secure or conditional synchronization:</p>
        <div class="code-block">local_log := "System Status: Online"
remote_hq := "Standby"
is_secure := true

// Only sync if connection is secure
// Syntax: target <-[condition]-> source
remote_hq <-[is_secure]-> local_log

// If not secure, sync is blocked
is_secure = false
// Now changes won't propagate to remote_hq</div>

        <h3>Real-World Example: Power Grid Controller</h3>
        <div class="code-block">// Priority-based source selection using conditional pulls
solar := 500.0
battery := 300.0
grid := 1000.0
demand := 450.0

active_source := "None"
power := 0.0

// Priority 1: Solar (if sufficient)
use_solar := solar >= demand
power <-[use_solar]- solar
active_source <-[use_solar]- "Solar"

// Priority 2: Battery (if solar fails)
use_battery := !use_solar & battery >= demand
power <-[use_battery]- battery
active_source <-[use_battery]- "Battery"

// Priority 3: Grid (fallback)
use_grid := !use_solar & !use_battery
power <-[use_grid]- grid
active_source <-[use_grid]- "Grid"</div>
      </div>

      <div class="doc-section" id="gates">
        <h2>Conditional Gates</h2>
        <p>Gates filter or transform data inline using <code>-[condition]-></code> syntax.</p>

        <h3>Simple Gate (Filter)</h3>
        <p>Only execute if condition is true:</p>
        <div class="code-block">value := 75

// Only calls ProcessHigh if value > 50
value -[value > 50]-> ProcessHigh

// Only calls ProcessLow if value ≤ 50
value -[value ≤ 50]-> ProcessLow</div>

        <h3>Transform Gate</h3>
        <p>Transform the value before passing:</p>
        <div class="code-block">input := 10

// If condition is true, pass the transformed value
input -[input > 5 ? input * 2]-> Handler     // Passes 20
input -[input > 5 ? "HIGH"]-> Classifier     // Passes "HIGH"</div>

        <h3>Complex Conditions</h3>
        <div class="code-block">status := "Active"
power := 80

// Compound conditions
status -[status == "Active" & power > 90]-> CriticalHandler
status -[status == "Active" & (power > 90 | power < 10)]-> AlertHandler</div>

        <h3>Gates with Any Arrow</h3>
        <div class="code-block">// Gate + Fuzzy
temp -[lockdown == false]~> Regulator

// Gate + Solver
position -[obstacles < 5]=> PathFinder</div>
      </div>

      <div class="doc-section" id="chaining">
        <h2>Arrow Chaining</h2>
        <p>Combine multiple arrows in a single expression for complex pipelines.</p>

        <h3>Basic Chain</h3>
        <div class="code-block">input -> Step1 -> Step2 -> Step3 -> Print</div>

        <h3>Capture from Chain</h3>
        <div class="code-block">// Chain flows and capture result
result <- Transform(input)
result <- input -> Transform -> Validate</div>

        <h3>Mixed Arrow Chain</h3>
        <div class="code-block">// Gate -> Flow -> Fuzzy -> Solver -> Fork
data -[valid]-> Decrypt ~> Analyze => Solve -< Log, Alert</div>

        <h3>The "Omega Chain"</h3>
        <p>Maximum complexity—combining all arrow types:</p>
        <div class="code-block">// 1. Gate check on radiation
// 2. Forward to Decrypt
// 3. Fuzzy to Analyzer
// 4. Solver for geometry
// 5. Fork to multiple outputs

artifact -[radiation < 10]-> Decrypt ~> Analyzer => Solver -< Log, Alert</div>
      </div>
    </main>
  </div>

  <footer>
    <p>Ouroboros Language © 2026</p>
  </footer>

  <script>
    // Add copy buttons to all code blocks
    document.addEventListener('DOMContentLoaded', function() {
      const codeBlocks = document.querySelectorAll('.code-block');
      
      codeBlocks.forEach((block, index) => {
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block-wrapper';
        block.parentNode.insertBefore(wrapper, block);
        wrapper.appendChild(block);
        
        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.setAttribute('data-code-index', index);
        
        wrapper.appendChild(copyBtn);
        
        // Copy functionality
        copyBtn.addEventListener('click', function() {
          const code = block.textContent;
          navigator.clipboard.writeText(code).then(() => {
            // Show success state
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.classList.remove('copied');
            }, 2000);
          }).catch(err => {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
            }, 2000);
          });
        });
      });
    });
  </script>
</body>
</html>
